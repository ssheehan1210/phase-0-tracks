# Release 0: Implement a Simple Search

# Write a method that takes an array of integers and an integer to
# search for. The method should return the index of the item, or nil
# if the integer is not present in the array. Don't use built-in array
# methods like .index. You are allowed to use .length and .each.

# First, you need to create a simple array that the method will be
# searching through. Then define a new method that will go through
# the array in search of the called number (referred to as digit in
# this method). If the number is found/true, the index number will
# become the return value and can be printed. Otherwise, the return
# value will be nil.

# simple_arr = [7, 12, 26, 42, 37, 3]

# def search_array(simple_arr, digit)
# integer = nil
#	simple_arr.length.times do |i|
#		if simple_arr[i] == digit
#			integer = i
#		end
#	end
#p integer
#end

#search_array(simple_arr, 12)
#	=> 1



# Release 1: Calculate Fibonacci Numbers

# Create a method that takes a number of Fibonacci terms to generate
# and returns an array of the terms. (Hint: The last number in the
# array generated by fib(100) will be 218922995834555169026. How can
# you verify this without having to compare this huge number manually?)

# Start off by creating a new empty array that is initialized with 100
# available areas to insert values into. Next, define a new method
# that will create the Fibonacci sequence that will continue until it
# reaches the called number. As a reminder, the first two Fibonacci
# numbers will be 0 and 1, though sometimes other sequences start with
# two 1s instead. Each Fibonacci number equals the sum of the previous
# two numbers, so the first two numbers (0 and 1) need to be set
# before kicking off the automatic generation of the other numbers.

answer_arr = Array.new

def fibonacci_seq(number)
	first_fib = 0
	second_fib = 1
	number.times do
		fib_integer = first_fib
		first_fib = second_fib
		second_fib = fib_integer + second_fib
	end
	return first_fib
end

# To verify, run the lines of data below and look at the last array
# printed on your Terminal. The last number in the array should equal
# the last number of fib(100) from the instructions.

100.times do |number|
	answer_arr << fibonacci_seq(number)
	p answer_arr
end



# Release 2: Sort an Array

# Choose a simple sorting algorithm to learn about. Bubble sort or
# insertion sort are good ones for beginners, but you're welcome to
# be more adventurous.

# Form a conceptual understanding of how the algorithm works. What
# helps you grasp it? Do visualizations help? How can you find the
# right materials for yourself?

# Notice your emotional state as you tackle this algorithm: do you
# feel frustrated, underqualified, stupid, or overwhelmed? Or is it
# more like excitement and curiosity? How do you think these feelings
# affect your ability to learn?



# "Bubble Sort" Algorithm:

#def bubble_sort(array)
#	n = array.length
#	loop do
#		swapped = false
#
#		(n-1).times do |i|
#			if array[i] > array[i+1]
#				array[i], array[i+1] = array[i+1], array[i]
#				swapped = true
#			end
#		end
#
#		break if not swapped
#	end
#
#	array
#end

# Go through the list and put two adjacent elements in descending
# order. However, you will have to repeatedly loop through the list
# until there are no longer any swaps to make, thus meaning that the
# list is finished sorting.

# The main variable that determines whether the loop continues or is
# broken is called 'swapped'. As the name implies, 'swapped' is true
# if any swaps are made in a single pass through the array. If no
# swaps were made throughout the entire pass through the array, the
# 'swapped' variable returns as false and the result is a completely
# sorted list.



# Pseudocode a sorting method that takes an array of integers and
# uses a sorting algorithm. The method should return a sorted version
# of the array. Your pseudocode should not be Ruby-specific.
# Implement the sorting method in Ruby.

# Start out by making the array of integers that we will be sorting.

new_array = [1, 5, 14, 11, 78, 34, 22, 20]

# Next, we will define sorting method that will get each of these
# integers in the right order. Start off by naming the new method
# and indicate that the input will be an array.

def new_bubble_sort(array)

	# Next, to ensure that each integer in the array is accounted
	# for, regardless of how large the array is, establish a value
	# for the entire length of the array

	arr_len = array.length

	# Now is the time to begin your search's loop, making it so that
	# the loop will start with 'swapped' reading as false and only
	# end when it reaches the end with 'swapped' still as false.

	loop do
		swapped = false

		# Now that the main loop can be broken out of, create an
		# if...else statement to provide conditions where swapped can
		# be changed into true.

		# Start by setting if...else statement to cycle the same
		# number of times as one number less than the array's length.
		# (This is done to ensure it will cycle enough times to shift
		# all necessary integers)

		(arr_len-1).times do |int|

			# Make it so that if any integer at a particular index is
			# larger than the integer in the next index, it will be
			# swapped places with each other.

			if array[int] > array[int+1]
				array[int], array[int+1] = array[int+1], array[int]

				# Once the condition is fulfilled, the value for
				# 'swapped' will be changed to true.

				swapped = true
			end
		end

		# If the loop at this point hasn't made any swaps within the
		# array, then the value for 'swapped' remains false and will
		# break the loop.

		break if not swapped
	end

	# Finally, call the array value at the end of the sorting method
	# definition so that the value maintains all the changes made by
	# the previous loop.

	array
end

# You can now verify your results by putting your unsorted array
# through the now defined sorting method.

p new_bubble_sort(new_array)
# => [1, 5, 11, 14, 20, 22, 34, 78]
